function tsdBasicSimulationTutorial% tsdBasicSimulationTutorial%% Simulation of basic ideal observer performance for% a yes-no task.  Computes hits and false alarms by% simulation for an observer that compares log likelihood% ratio to a criterion.%% Computation of log likelihood ratio requires knowledge% of the parameters of the underlying p(x|s) and p(x|n)% distributiions.  These are specified so we know them,% but that isn't a realistic observer model.  For grins,% the code also estimates these parameters from a set% of observations, and then uses the estimates.  The% estimates are computed in batch mode, so it still isn't% a fully realistic observer model.%% This code could be easily modified to sweep the criterio% and plot an ROC curve.%% A second exercise would be to compute optimal criterion % as a function of prior odds and a payoff matrix, and then% plot payoff as a function of criterion.%% A third exercise would be to modify so that the% distributional properties are computed using some sort% of running average, and see how many trials itS takes for % performance to approach ideal.%% Requires statistics toolbox.% % 9/28/04  dhb  Wrote from an earlier TSD simulation.% 7/10/09  dhb  Change name, added some comments.% Number of simulation trials to run.  Increase to% improve simulation accuracy, decrease to speed it up.Nrepeats = 10;Ntrials = 1000;% Prior odds.ps = 0.5;pn = 1 - ps;% Signal and noise distribution parameters% We will assume both distributions are normal,% so that we specify mean (u) and variance (var)% of eachun = 1;varn = 1;us = 3;vars = 1;% CriterionlogBeta = 0;% Run simulation using true population variables in ideal observer.fprintf('\nPopulation stats\n');fprintf('\tSignal mean: %g, signal var: %g\n',us,vars);fprintf('\tNoise mean: %g, noise var: %g\n',un,varn);for i = 1:Nrepeats	[Ph(i),Pfa(i),x,isS] = RunSimulation(Ntrials,ps,pn,un,varn,us,vars,un,varn,us,vars,logBeta);endfprintf('Population stat ideal observer (%d trials, %d repeats):\n\thit rate %0.2f +/- %0.3f,\n\tfalse alarm rate %0.2f +/- %0.3f\n',...	Ntrials,Nrepeats,...	mean(Ph),std(Ph)/sqrt(length(Ph)),mean(Pfa),std(Pfa)/sqrt(length(Ph)));% Now extract "population" variables from observations.nToExamine = 200;for i = 1:Nrepeats	% Choose random index of observations from vector x.	list = rand(nToExamine,1); index = floor( Ntrials .* list ) + 1;	% Compute mean and var of signal and noise observations	use_x = x(index);	use_isS = isS(index);	use_us = mean(use_x(find(use_isS == 1)));	use_vars = var(use_x(find(use_isS == 1)));	use_un = mean(use_x(find(use_isS == 0)));	use_varn = var(use_x(find(use_isS == 0)));	% Simulate using these.	[use_Ph(i),use_Pfa(i)] = RunSimulation(Ntrials,ps,pn,un,varn,us,vars,use_un,use_varn,use_us,use_vars,logBeta);endfprintf('Extracted stat ideal observer (%d trials, %d repeats):\n\thit rate %0.2f +/- %0.3f,\n\tfalse alarm rate %0.2f +/- %0.3f\n',...	Ntrials,Nrepeats,...	mean(use_Ph),std(use_Ph)/sqrt(length(use_Ph)),mean(use_Pfa),std(use_Pfa)/sqrt(length(use_Pfa)));return% [Ph,Pfa,x] = RunSimulation(NTrials,un,varn,us,vars,...%		use_un,use_varn,use_us,use_vars,logBeta)%% Run out the simulation, using a criterion on the likelihood.% Written as a function so we can call it over and over again.% This is written for clarity rather than speed -- could be% made much faster.%% 9/28/04		dhb		Pulled it out as a function.function [Ph,Pfa,x,is_s_or_n] = RunSimulation(Ntrials,ps,pn,un,varn,us,vars,...	use_un,use_varn,use_us,use_vars,logBeta)% Counter variables to record trial by trial outcomesNh = 0;Nfa = 0;Nm = 0;Ncr = 0;Nsignal = 0;Nnoise = 0;% Simulate out for decisions based on true population statistics.% The logic here just goes through the trials one by one and% simulates generation of observation and then decision.x = zeros(Ntrials,1);is_s_or_n = zeros(Ntrials,1);for i = 1:Ntrials  % Determine whether trial is s or n and get a   % draw of x from appropriate distribution.  is_s_or_n(i) = (rand(1,1) < ps);  if ( is_s_or_n(i) == 1 )		  x(i) = normrnd(us,sqrt(vars));    Nsignal = Nsignal + 1;  else	  x(i) = normrnd(un,sqrt(varn));    Nnoise = Nnoise + 1;  end  % Compute log likelyhood ratio	likelisignal = normpdf(x(i),use_us,sqrt(use_vars));	likelinoise = normpdf(x(i),use_un,sqrt(use_varn));  loglikelyr = log(likelisignal/likelinoise);  % Decide which we want	 if (loglikelyr < logBeta)    say_s_or_n = 0;  else    say_s_or_n = 1;  end  % Record outcome  if ( is_s_or_n(i) == 0 & say_s_or_n == 0 )    Ncr = Ncr+1;  elseif ( is_s_or_n(i) == 0 & say_s_or_n == 1 )    Nfa = Nfa+1;  elseif ( is_s_or_n(i) == 1 & say_s_or_n == 0 )    Nm = Nm+1;  else    Nh = Nh+1;  endend% Compute hit and false alarm rates, print them out.Ph = Nh/Nsignal;Pfa = Nfa/Nnoise;return